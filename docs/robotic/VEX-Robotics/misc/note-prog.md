# 2023 VEX 赛事 工程笔记-程序篇

个人认为，程序是机器人赛事的重要组成部分。在这篇笔记中，我们将细细阐述对 VEX 赛事基本流程的理解与阐释，以及相关的程序实现。

## 术语

下面列出了本笔记使用的一些技术术语。

- 自动时段奖励分 – 自动赛时段结束时得分最多的联队获得奖励分值。
- 自动获胜分 – 每局资格赛的自动赛时段结束时，完成一系列规定任务的联队获得的奖励分值。
- 赛局 – 一个设定的时间段，包含自动赛时段和手动控制时段，在这段时间内，赛队使用特定版本的扭转乾坤规则通过比赛获取分值，见第四章。
  - 自动赛时段 – 这是一局比赛开始时的一个时段，此时机器人的运行和反应只能受传感器输入和学生预先写入机器人主控器的命令的影响。
  - 手动控制时段 – 由上场队员通过遥控器控制机器人运行的一个时段。
- 机器人 – 通过验机的机器，被设计用于自动地和/或在上场队员遥控下执行单个或多个任务。

## 规则解释

通过阅读官方规则文档，我们获得了以下信息：

### 计分规则

| 条件 | 得分 |
| :-: | :-: |
| 每个在高筐内得分的飞盘 | 5分 |
| 每个在领地内得分的飞盘 | 1分 |
| 每个被占据的双色筒 | 10分 |
| 每块被覆盖的泡沫垫 | 3分 |
| 赢得自动时段奖励分 | 10分 |

### 赛事规则

- 使用“竞赛模板”编程。机器人的编程须遵循由 VEX网 场地控制器发出的指令。在自动赛时段，不允许上场队员使用他们的V5遥控器。因此，如果赛队想在自动赛时段有所表现，就要用定制的软件对机器人编程。机器人的编程须遵循由 VEX网 场地控制器发出的控制指令（如，忽略自动赛时段的无线通讯，在手动控制阶段结束时禁用等）。赛队须使用提供的“竞赛模板”或等同功能的程序模板来实现此要求。关于这方面的更多信息，赛队可查询所选择的编程软件的开发人员编制的指南。

## 操作流程

此次赛事主要分为自动赛和手动控制时段，具体情况见下。

| 时段 | 限时 |
| :-: | :-: |
| 自动赛时段 | 15 秒 |
| 手动控制时段 | 105 秒 |

### 自动赛时段

自动赛时段历时 15 秒，初步计划完成以下任务：

1. 机器人初始状态带有两个飞盘，先尝试向高筐射出飞盘。
2. 旋转底盘，使机器人与网格对齐。
3. 机器人前进至位于滚筒左侧，原地转弯，滚动我方滚筒至对应颜色。

#### 实现过程 {#imp-1}

与手动控制相比，我们结合网格线，经过多次测试，加入了以网格为单位的控制函数：

```cpp
void goForwardGrid(int t, bool intake) {}
void goBackwardGrid(int t, bool intake) {}
// 按网格为单位的前进后退，t 表示网格数，intake 声明是否边转滚轮边前进（适用于自动转滚筒）
void turnLefts(float r) {}
void turnRights(float r) {}
// 按固定弧度为单位的左右转弯
void Spin() {}
// 转动滚筒的较低层封装
```

#### 细节与注意事项 {#note-1}

1. 对于一些精确性要求高的动作（比如前进、转弯等），程序默认的实现方式是 `const` 即自然停止，由于惯性机器人会继续前进，导致准确度降低。此时应该使用 `hold` 即锁定方式，这样直接锁死，可以保证机器人停止在需要的位置。

### 手动控制时段

手动控制时段历时 105 秒（即 1 分 45 秒），主要完成如下任务：

1. 发射飞盘到对方高/低筐位置。
2. 转动滚筒。
3. 应对对抗问题。
4. 对局最后阶段，控制机器人占地面积扩增。

#### 控制与按键绑定

手动控制程序应该专注于提供顺滑流畅的操作体验。因此我们询问了队内其他成员的意见，花了一段时间精心研究后，设计出这样的按键绑定方案：

| 按键 | 操作 |
| :-: | :-: |
| Ch3 （左摇杆上下） | 控制底盘前进、后退 |
| Ch1 （右摇杆左右） | 控制底盘左转、右转 |
| L1/L2 | 控制飞轮 |
| R1/R2 | 同步控制滚轮与传送带 |
| X/Y | 控制气缸电动开关 |
| A | 执行投入高筐的自动动作 |
| B | 执行投入低筐的自动动作 |

#### 实现过程 {#imp-2}

单独控制的底层函数如下：

```cpp
void ChassisControl(float lPower, float rPower) {}
void Move(float lPower, float rPower) {}
void Stop(brakeType type) {}
void RollersControl(int power) {}
void IntakeControl(int power) {}
void FlywheelsControl(int power) {}
```

在此基础上加入了一些封装的模板函数：

```cpp
void Shoot(int t) {} // 将飞盘投掷到高筐
void ShootLow() {} // 将飞盘投掷到低框
```

#### 细节与注意事项 {#note-2}

1. 主程序不应直接循环，以免浪费电池与处理器资源。因此我们考虑在循环体内加入延迟：`sleep(20);`。
2. 底盘电机的控制过程需要根据实际转动情况进行更改与进一步校正。
